{
    "collab_server" : "",
    "contents" : "#Zero-Inflated Poisson model\n\n#Zero-Inflated Poisson likelihood:\n\n#              {   p,                   zi = 1\n#    Yi|zi =   {\n#              {   1 - p * f(x|lam),    zi = 0 \n\n# logit(p) = g(p) = BX = B0 + B1*x1 + B2*x2 ...\n# f(x|lam) ~ Poisson(lam)\n# zi ~ Binomial(1, p)\n# lambda ~ Gamma(a, b)\n\n\n#________________________________________________\n#Documentation\n\n\n#' Zero-Inflated Poisson Regression Model\n#' \n#' @description \\code{zero_poisson} is used to fit zero-inflated \n#' poisson regression models to count data via Bayesian inference.\n#' \n#' @param y numeric response vector.\n#' \n#' @param x numeric predictor matrix.\n#' \n#' @param a shape parameter for gamma prior distributions.\n#' \n#' @param b rate parameter for gamma prior distributions.\n#' \n#' @param lam.start initial value for lambda parameter.\n#' \n#' @param beta.prior.mean mu parameter for normal prior distributions.\n#' \n#' @param beta.prior.sd standard deviation for normal prior distributions.\n#' \n#' @param iters number of iterations for the Markov chain to run.\n#' \n#' @param burn numeric burn-in length.\n#' \n#' @param nthin numeric thinning rate.\n#' \n#' @param plots logical operator. \\code{TRUE} to output plots.\n#' \n#' @param progress.bar logical operator. \\code{TRUE} to print progress bar.\n#' \n#' @details \n#' \n#' @return \\code{zero_poisson} returns a list which includes the items\n#' \\describe{\n#'    \\item{lam}{numeric vector; posterior distribution of lambda parameter}\n#'    \\item{beta}{numeric matrix; posterior distributions of regression coefficients}\n#'    \\item{p}{numeric vector; posterior distribution of parameter 'p', the \n#'    probability of a given zero observation belonging to the model's zero component}\n#'    \\item{ll}{numeric vector; posterior log-likelihood}    \n#' }\n#' \n#' @author \n#' Taylor Trippe <\\email{ttrippe@@luc.edu}> \\cr\n#' Earvin Balderama <\\email{ebalderama@@luc.edu}>\n#' \n#' @examples  \n#' \n\n#________________________________________________\n#Source code\n\nzero_poisson <- function(y, x, a = 1, b = 1, lam.start = 1,\n                         beta.prior.mean = 0, beta.prior.sd = 1,\n                         iters = 1000, burn = 500, nthin = 1,\n                         plots = T, progress.bar = T) {\n  \n  \n  #Initial values\n  pb <- txtProgressBar(min = 0, max = iters, style = 3)\n  x <- cbind(1, x)\n  x.col <- ncol(x)\n  z <- rep(1, length(y))\n  B <- rep(beta.prior.mean, length.out = x.col)\n  XB <- x%*%B\n  p <- 1/(1 + exp(-XB))\n  lam <- lam.start\n  ll <- loglik_zip(y = y, z = z, lam = lam, p = p)\n  \n  #Tuning\n  beta.tune <- rep(0.02, x.col)\n  lam.tune <- 0.02\n  beta.acc <- rep(0, x.col)\n  lam.acc <- 0\n  att <- 0\n  \n  #Create matrix of MCMC values for all parameters B, lambda  \n  keep.beta <- matrix(0, iters, length(B))\n  keep.lam <- rep(lam, iters)\n  keep.ll <- rep(sum(ll), iters)\n  keep.p <- rep(mean(p), iters)\n  \n  #MCMC start\n  for(i in 2:iters) {for(thin in 1:nthin){\n    \n    att <- att + 1\n    \n    #Update p (Update Betas)\n    \n    for(j in 1:x.col){\n      \n      beta.current <- B[j]\n      beta.new <- rnorm(1, beta.current, beta.tune[j])\n      XB.new <- XB + x[,j]*(beta.new - beta.current)\n      p.new <- 1/(1 + exp(-XB.new))\n      ll.new <- loglik_zip(y = y, z = z, lam = lam, p = p.new)\n      \n      p.ratio <- sum(ll.new) + sum(dnorm(beta.new, beta.prior.mean, beta.prior.sd, log = T)) - \n        sum(ll) - sum(dnorm(beta.current, beta.prior.mean, beta.prior.sd, log = T))\n      #if(is.finite(p.ratio))\n      if(log(runif(1)) < p.ratio){\n        \n        B[j] <- beta.new\n        XB <- XB.new\n        p <- p.new\n        ll <- ll.new\n        beta.acc[j] <- beta.acc[j] + 1\n      }\n    }\n    \n    #Update z\n    \n    P1 <- ifelse(y==0, 1, 0)*p\n    P0 <- dpois(y, lam)*(1 - p)\n    z  <- rbinom(length(y), 1, P1/(P1 + P0))\n    ll <- loglik_zip(y = y, z = z, lam = lam, p = p)\n    \n    #Update lambda\n    \n    lam.current <- lam\n    lam.new <- exp(rnorm(1, log(lam.current), lam.tune))\n    \n    lam.ratio <- dgamma(lam.new, a, b, log = T) + sum(dpois(y[z==0], lam.new, log = T)) - \n      dgamma(lam.current, a, b, log = T) - sum(dpois(y[z==0], lam.current, log = T))\n    \n    if(log(runif(1)) < lam.ratio) {\n      lam <- lam.new\n      lam.acc <- lam.acc + 1\n      ll <- loglik_zip(y = y, z = z, lam = lam.new, p = p)\n    }\n    \n  }#End thinning\n    \n    \n    keep.beta[i,] <- B\n    keep.lam[i] <- lam\n    keep.ll[i] <- sum(ll)\n    keep.p[i] <- mean(p)\n    \n    \n    #Update tuning parameters\n    \n    if(i < 0.75*burn & att > 50){\n      beta.tune <- ifelse(beta.acc/att < 0.20, 0.8*beta.tune, beta.tune)\n      beta.tune <- ifelse(beta.acc/att > 0.50, 1.2*beta.tune, beta.tune)\n      lam.tune <- ifelse(lam.acc/att < 0.20, 0.8*lam.tune, lam.tune)\n      lam.tune <- ifelse(lam.acc/att > 0.50, 1.2*lam.tune, lam.tune)\n      \n      beta.acc <- rep(0, x.col)\n      lam.acc <- att <- 0\n    }\n    \n    \n    #Plots\n    if(plots==T){\n      if(i > burn & i%%100==0){\n        \n        par(mfrow = c(1,3))\n        plot(keep.lam[burn:i], type = \"s\",\n             ylab = \"\", main = bquote(Mean~lambda))\n        abline(h = mean(keep.lam[burn:i]), col = 2)\n        plot(keep.p[burn:i],type=\"s\",\n             ylab = \"\", main = bquote(beta[0]~Zero~Prob))\n        abline(h = mean(keep.p[burn:i]), col = 2)\n        plot(keep.ll[burn:i], type = \"s\",\n             ylab = \"\", main = bquote(Log~Likelihood))\n        abline(h = mean(keep.ll[burn:i]), col = 2)\n      }\n    }\n    \n    if(progress.bar){setTxtProgressBar(pb, i)}\n  }\n  \n  \n  return(list(lam = keep.lam[(burn + 1):iters],\n              beta = keep.beta[(burn + 1):iters,],\n              p = keep.p[(burn + 1):iters,],\n              ll = keep.ll[(burn + 1):iters,]\n  ))\n  \n}\n\n\n",
    "created" : 1478539484678.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4158625033",
    "id" : "932E47A6",
    "lastKnownWriteTime" : 1478199326,
    "last_content_update" : 1478540564475,
    "path" : "~/GitHub/hurdlr/hurdlr/R/zero_poisson.R",
    "project_path" : "hurdlr/R/zero_poisson.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}